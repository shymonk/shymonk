<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
	"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>stackless-python.html</title>

</head>

<body>

<p>Title: Stackless Python 探秘
Date: 2016-06-01 22:00
Category: Python
Tags: stackless, python</p>

<p>提到stackless python， 相信很多人早已对其有所耳闻。作为Python解释器的另一种实现，其设计思路对整个Python世界产生了
深远影响。坦白的讲，我并没有大规模stackless python 的应用经验，本文意在对其背后实现原理进行探索。如果你和我一样对它感到好奇，欢迎深入阅读。</p>

<h1>Stackless历史</h1>

<ul>
<li>1998年， 作者Christian Tismer便开始了Stackless Python 1.0版本的开发。作为雏形版本， Tismer 首次在Python中加入了<code>continuation</code> 这一抽象概念的实现。</li>
<li>2000年，以Stackless Python为背景的<a href="https://www.python.org/dev/peps/pep-0219/">PEP 0219</a> 出现了。根据 Stackless PEP的描述，Tismer希望Stackless 相关的代码能够成为Python核心的一部分。然而，他的这一提议在Python开发者当中备受争议。出于代码简洁性的考虑，一些开发者认为 stackless相关代码虽然功能强大但是晦涩难懂并且难以维护，加之其对于Jython并不兼容。最终，这一提议没有成为现实。</li>
<li>2002年，Stackless Python 2.0版本诞生。在这一版本中，Tismer彻底重写了代码并放弃了原有的 <code>continuation</code> 实现。取而代之的是一种新的"一次性" <code>continuation</code> - <code>tasklets</code> 。</li>
<li>2004年，Stackless Python 3.0版本诞生。它包含2.0版本的全部功能并加入了一个重要概念： <code>soft-switching</code> 用于将程序的执行状态序列化（Pickling of Program State）。</li>
</ul>

<p>其实，早在1999年stackless PEP被提出之前，Python核心开发者Sam Rushing便开发了一个直接通过切换<code>C-Stack</code> 实现的协程模块。然而，与stackless 一样，Python开发人员一致认为其不应该合并到Python核心代码中。理由很简单：由于各硬件平台和编译器对于<code>C-Stack</code> 的处理不尽相同，对于Python这样一种跨平台语言来说，添加平台依赖的代码将大大增加其移植的难度。
经过多年的发展，如今的Stackless Python已经摆脱了当初的麻烦。作为一个与<code>CPython</code>完全兼容的Package 被广大Python用户所使用。正如Tismer所说，"现在的Stackless只提供最干净的概念——<code>Microthreads</code>， 至于那些对稀奇古怪事物不感兴趣的人根本不会真正认识Stackless，只是碰巧它更快。"</p>

<h1>为什么使用Stackless Python?</h1>

<p>Python中并发的两种方式，线程(Thread) 进程(Process) 对于大规模并发的程序来说，这两种方式开销过大。
相比线程和进程，协程(coroutine)是一种更为自然并且低开销的并发解决方案。它为广泛应用于模拟器，游戏，异步IO以及其他事件驱动的编程模型中。
然而，在Python2.2之前的版本，Python并没有实现对协程的支持，直到生成器(generator)这一近似协程的出现，Stackless的诞生正是为了解决这个问题。</p>

<h1>Stackless Python是如何工作的?</h1>

<h2>Stackfull Python</h2>

<p>为了更好的理解<code>stackless</code>，我们以下面这段代码为例，简要介绍<code>stackfull</code>的<code>C-Python</code>解释器栈结构以及它是如何工作的。</p>

<p>```
def a(x):
    b(x + 1)</p>

<p>def b(x):
    c(x * x)</p>

<p>def c(x):
    print 'x=', x</p>

<p>a(42)
```</p>

<p>在Python shell中执行上面这段代码时，解释器中<code>C-stack</code>和<code>Python-stack</code>结构如下图。</p>

<p><img src="{filename}/images/stackfull-python.png" alt="standard 'stackfull' python" title="" /></p>

<p>可以看出，Python解释器以函数<code>PyRun_InteractiveOne</code>作为入口，递归调用<code>call_function</code>以及<code>eval_code2</code>，从而形成<code>C-stack</code>。在<code>eval_code2</code>内部，通过调用<code>PyFrame_New</code>构造相应函数栈帧结构<code>PyFrameOjbect</code>，从而形成类似<code>C-stack</code>一样的<code>Python-stack</code>。</p>

<h2>协程并发模型</h2>

<p>了解了<code>C-Python</code>执行的基本原理，我们再来看看基于协程的并发模型。</p>

<p><img src="{filename}/images/concurrency-model.png" alt="coroutine concurrency model" title="" /></p>

<p><strong>协程</strong>作为程序执行的最小单元并发执行时，会因为主动放弃执行权限而被挂起。因此，调度系统必须同时维护多个函数执行上下文，以实现非本地跳转（non-local jump）。与线程相比，协程并发模型与其最大不同之处在于：</p>

<blockquote>
  <p>协程由应用程序实现调度，线程由操作系统实现调度</p>
</blockquote>

<h2>范式转换</h2>

<p>对于<code>stackfull</code>的标准Python而言，实现协程并发的核心在于将<code>Python-Stack</code> 与 <code>C-Stack</code>解耦，这种改变Python解释器执行过程的方法也被称作<strong>范式转换</strong>。要点可以归纳为以下三个方面：</p>

<p>1.函数栈帧执行时机    解释器执行<code>Python</code>函数的标准范式是：为函数的<code>PyCodeObject</code>构造一个函数栈帧<code>PyFrameObject</code>并附带所有参数，最后通过<code>eval_code2</code>解释执行相应的函数体直到其返回。</p>

<p>然而，以正确的调用顺序执行所有的函数栈帧并不意味着我们必须在当前<code>C-stack</code>嵌套层级中执行<code>eval_code2</code>。如果我们能够避免与<code>C-stack</code>相关的所有后续操作，就可以在函数栈帧执行前实现<code>C-stack</code>的退栈操作，从而达到解耦的目的。</p>

<p>2.参数生命周期
在标准python中，函数参数的引用由其上层调用者持有。这意味着只有下层函数返回后，其参数元组的引用才能被上层函数销毁。</p>

<p>现在，让我们换一种思维方式。很明显，函数参数应该与函数栈帧有着相同的生命周期，参数元组的引用也应该同函数栈帧一起被销毁。所以，我们在<code>PyFrameObject</code>结构中添加对参数元组的引用，就可以实现范式的转换。</p>

<p>3.系统状态
在标准python中，执行一个函数栈帧后的返回值会存在两种情况：</p>

<ol>
<li>返回<code>PyObject</code>代表函数正常执行。</li>
<li>返回<code>NULL</code>代表函数抛出异常。</li>
</ol>

<p>基于这两种基本系统状态，添加一个特殊的返回值类型<code>Py_UnwindToken</code>作为第三种系统状态，这样我们便可以在下层栈帧被执行之前实现<code>C-stack</code>退栈操作。</p>

<p>由于<code>Py_UnwindToken</code>与其他Python对象兼容，这一范式的转换对于大部分相关代码并不可见，我们只需要对执行栈帧的C函数做出修改即可。</p>

<p>Return Value   | 系统状态
:------------- | :-------
NULL           | 函数执行异常
Py_UnwindToken | 调度函数栈帧
Other PyObject | 作为正常结果返回</p>

<h1>参考资料</h1>

<ul>
<li><a href="http://archive.is/TwQEJ">http://archive.is/TwQEJ</a></li>
<li><a href="https://web.archive.org/web/20131005114137/http://www.onlamp.com/pub/a/python/2000/10/04/stackless-intro.html">https://web.archive.org/web/20131005114137/http://www.onlamp.com/pub/a/python/2000/10/04/stackless-intro.html</a></li>
<li><a href="http://www.onlamp.com/pub/a/python/2002/02/14/pythonnews.html">http://www.onlamp.com/pub/a/python/2002/02/14/pythonnews.html</a></li>
<li><a href="https://web.archive.org/web/20120508092636/http://islab.org/stackless/2007/stackless.html">https://web.archive.org/web/20120508092636/http://islab.org/stackless/2007/stackless.html</a></li>
<li><a href="https://ep2013.europython.eu/conference/talks/the-story-of-stackless-python">https://ep2013.europython.eu/conference/talks/the-story-of-stackless-python</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0219/">https://www.python.org/dev/peps/pep-0219/</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0342/">https://www.python.org/dev/peps/pep-0342/</a></li>
</ul>

</body>
</html>
