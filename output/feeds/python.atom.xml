<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>shymonk - Python</title><link href="http://shymonk.com/" rel="alternate"></link><link href="http://shymonk.com/feeds/python.atom.xml" rel="self"></link><id>http://shymonk.com/</id><updated>2016-06-01T22:00:00+08:00</updated><entry><title>Stackless Python 探秘</title><link href="http://shymonk.com/posts/2016/06/stackless-python-tan-mi/" rel="alternate"></link><published>2016-06-01T22:00:00+08:00</published><updated>2016-06-01T22:00:00+08:00</updated><author><name>shymonk</name></author><id>tag:shymonk.com,2016-06-01:/posts/2016/06/stackless-python-tan-mi/</id><summary type="html">&lt;p&gt;提到stackless python， 相信很多人早已对其有所耳闻。作为Python解释器的另一种实现，其设计思路对整个Python世界产生了
深远影响。坦白的讲，我并没有大规模stackless python 的应用经验，本文意在对其背后实现原理进行探索。如果你和我一样对它感到好奇，欢迎深入阅读。&lt;/p&gt;
&lt;h1&gt;stackless历史&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;1998年， 作者Christian Tismer便开始了Stackless Python 1.0版本的开发。作为雏形版本， Tismer 首次在Python中加入了&lt;code&gt;continuation&lt;/code&gt; 这一抽象概念的实现。&lt;/li&gt;
&lt;li&gt;2000年，以Stackless Python为背景的&lt;a href="https://www.python.org/dev/peps/pep-0219/"&gt;PEP 0219&lt;/a&gt; 出现了。根据PEP的描述，Tismer希望Stackless 相关的代码能够成为Python核心的一部分。然而，他的这一提议在Python开发者当中备受争议。出于代码简洁性的考虑，一些开发者认为 stackless相关代码虽然功能强大但是晦涩难懂并且难以维护，加之其对于Jython并不兼容。最终，这一提议没有成为现实。&lt;/li&gt;
&lt;li&gt;2002年，Stackless Python 2.0版本诞生。在这一版本中，Tismer彻底重写了代码并放弃了原有的&lt;code&gt;continuation …&lt;/code&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;提到stackless python， 相信很多人早已对其有所耳闻。作为Python解释器的另一种实现，其设计思路对整个Python世界产生了
深远影响。坦白的讲，我并没有大规模stackless python 的应用经验，本文意在对其背后实现原理进行探索。如果你和我一样对它感到好奇，欢迎深入阅读。&lt;/p&gt;
&lt;h1&gt;stackless历史&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;1998年， 作者Christian Tismer便开始了Stackless Python 1.0版本的开发。作为雏形版本， Tismer 首次在Python中加入了&lt;code&gt;continuation&lt;/code&gt; 这一抽象概念的实现。&lt;/li&gt;
&lt;li&gt;2000年，以Stackless Python为背景的&lt;a href="https://www.python.org/dev/peps/pep-0219/"&gt;PEP 0219&lt;/a&gt; 出现了。根据PEP的描述，Tismer希望Stackless 相关的代码能够成为Python核心的一部分。然而，他的这一提议在Python开发者当中备受争议。出于代码简洁性的考虑，一些开发者认为 stackless相关代码虽然功能强大但是晦涩难懂并且难以维护，加之其对于Jython并不兼容。最终，这一提议没有成为现实。&lt;/li&gt;
&lt;li&gt;2002年，Stackless Python 2.0版本诞生。在这一版本中，Tismer彻底重写了代码并放弃了原有的&lt;code&gt;continuation&lt;/code&gt; 实现。取而代之的是一种新的"一次性"&lt;code&gt;continuation&lt;/code&gt; - &lt;code&gt;tasklets&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;2004年，Stackless Python 3.0版本诞生。它包含2.0版本的全部功能并加入了一个重要概念： &lt;code&gt;soft-switching&lt;/code&gt; 用于将程序的执行状态序列化（Pickling of Program State）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实，早在1999年stackless PEP被提出之前，Python核心开发者Sam Rushing便开发了一个直接通过切换&lt;code&gt;C-Stack&lt;/code&gt; 实现的协程模块。然而，与stackless 一样，Python开发人员一致认为其不应该合并到Python核心代码中。理由很简单：由于各硬件平台和编译器对于&lt;code&gt;C-Stack&lt;/code&gt; 的处理不尽相同，对于Python这样一种跨平台语言来说，添加平台依赖的代码将大大增加其移植的难度。
经过多年的发展，如今的Stackless Python已经摆脱了当初的麻烦。作为一个与&lt;code&gt;CPython&lt;/code&gt;完全兼容的Package 被广大Python用户所使用。正如Tismer所说，"现在的Stackless只提供最干净的概念——&lt;code&gt;Microthreads&lt;/code&gt;， 至于那些对稀奇古怪事物不感兴趣的人根本不会真正认识Stackless，只是碰巧它更快。"&lt;/p&gt;
&lt;h1&gt;为什么使用stackless?&lt;/h1&gt;
&lt;p&gt;关于stackless，不得不提到&lt;a href="https://en.wikipedia.org/wiki/Coroutine"&gt;协程(coroutine)&lt;/a&gt;。对于大规模并发程序，传统的并发接口线程(Thread)和进程(Process)都有着较大的系统资源开销。与其相比，协程是一种更为自然并且低开销的并发解决方案。它被广泛应用于模拟器、游戏、异步IO以及其他事件驱动的编程模型中。然而，Python2.2之前的版本并没有实现对协程的支持，stackless的诞生正是为了解决这个问题。&lt;/p&gt;
&lt;h1&gt;并发模型&lt;/h1&gt;
&lt;p&gt;&lt;img alt="coroutine concurrency model" src="http://shymonk.com/images/concurrency-model.png"&gt;&lt;/p&gt;
&lt;p&gt;并发系统从本质上讲，是一系列独立的执行单元（&lt;code&gt;routine&lt;/code&gt;）在调度器的调度之下交替执行。与线程相比，协程并发模型与其最大不同之处在于：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;协程由应用程序实现调度，线程由操作系统实现调度&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于协程作为执行单元并发执行时，会因为主动放弃执行权限而被挂起，调度系统必须同时维护多个函数执行上下文，以实现非本地跳转（non-local jump）。&lt;/p&gt;
&lt;h1&gt;stackless是如何工作的?&lt;/h1&gt;
&lt;h2&gt;Stackfull Python&lt;/h2&gt;
&lt;p&gt;为了更好的理解&lt;code&gt;stackless&lt;/code&gt;，我们以下面这段代码为例，先简要介绍&lt;code&gt;stackfull&lt;/code&gt;的&lt;code&gt;C-Python&lt;/code&gt;解释器栈结构以及它是如何工作的。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;def a(x):
    b(x + 1)

def b(x):
    c(x * x)

def c(x):
    print &amp;#39;x=&amp;#39;, x

a(42)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在Python shell中执行上面这段代码时，解释器中&lt;code&gt;C-stack&lt;/code&gt;和&lt;code&gt;Python-stack&lt;/code&gt;结构如下图。&lt;/p&gt;
&lt;p&gt;&lt;img alt="standard 'stackfull' python" src="http://shymonk.com/images/stackfull-python.png"&gt;&lt;/p&gt;
&lt;p&gt;Python虚拟机以&lt;code&gt;eval_code2&lt;/code&gt;作为解释函数执行&lt;code&gt;a&lt;/code&gt;时，首先通过&lt;code&gt;PyFrame_New&lt;/code&gt;构造&lt;code&gt;a&lt;/code&gt;的栈帧&lt;code&gt;frame-a&lt;/code&gt;并返回&lt;code&gt;eval_code2&lt;/code&gt;，然后执行&lt;code&gt;a&lt;/code&gt;对应的Python代码。由于&lt;code&gt;a&lt;/code&gt;嵌套调用&lt;code&gt;b&lt;/code&gt;，此时解释器递归调用&lt;code&gt;eval_code2&lt;/code&gt;并重复之前过程执行&lt;code&gt;b&lt;/code&gt;，从而形成&lt;code&gt;C-stack&lt;/code&gt;和由&lt;code&gt;PyFrameObject&lt;/code&gt;构成的&lt;code&gt;python-stack&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;范式转换&lt;/h2&gt;
&lt;p&gt;对于&lt;code&gt;stackfull&lt;/code&gt;的标准Python而言，实现协程并发的核心在于将&lt;code&gt;Python-Stack&lt;/code&gt; 与 &lt;code&gt;C-Stack&lt;/code&gt;解耦，这种改变Python解释器执行过程的方法也被称作&lt;strong&gt;范式转换&lt;/strong&gt;。要点可以归纳为以下三个方面：&lt;/p&gt;
&lt;p&gt;1.函数栈帧执行时机    解释器执行&lt;code&gt;Python&lt;/code&gt;函数的标准范式是：为函数的&lt;code&gt;PyCodeObject&lt;/code&gt;构造一个函数栈帧&lt;code&gt;PyFrameObject&lt;/code&gt;并附带所有参数，最后通过&lt;code&gt;eval_code2&lt;/code&gt;解释执行相应的函数体直到其返回。&lt;/p&gt;
&lt;p&gt;然而，以正确的调用顺序执行所有的函数栈帧并不意味着我们必须在当前&lt;code&gt;C-stack&lt;/code&gt;嵌套层级中执行&lt;code&gt;eval_code2&lt;/code&gt;。如果我们能够避免与&lt;code&gt;C-stack&lt;/code&gt;相关的所有后续操作，就可以在函数栈帧执行前实现&lt;code&gt;C-stack&lt;/code&gt;的退栈操作，从而达到解耦的目的。&lt;/p&gt;
&lt;p&gt;2.参数生命周期
在标准python中，函数参数的引用由其上层调用者持有。这意味着只有下层函数返回后，其参数元组的引用才能被上层函数销毁。&lt;/p&gt;
&lt;p&gt;现在，让我们换一种思维方式。很明显，函数参数应该与函数栈帧有着相同的生命周期，参数元组的引用也应该同函数栈帧一起被销毁。所以，我们在&lt;code&gt;PyFrameObject&lt;/code&gt;结构中添加对参数元组的引用，就可以实现范式的转换。&lt;/p&gt;
&lt;p&gt;3.系统状态
在标准python中，执行一个函数栈帧后的返回值会存在两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;返回&lt;code&gt;PyObject&lt;/code&gt;代表函数正常执行。&lt;/li&gt;
&lt;li&gt;返回&lt;code&gt;NULL&lt;/code&gt;代表函数抛出异常。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;基于这两种基本系统状态，添加一个特殊的返回值类型&lt;code&gt;Py_UnwindToken&lt;/code&gt;作为第三种系统状态，这样我们便可以在下层栈帧被执行之前实现&lt;code&gt;C-stack&lt;/code&gt;退栈操作。&lt;/p&gt;
&lt;p&gt;由于&lt;code&gt;Py_UnwindToken&lt;/code&gt;与其他Python对象兼容，这一范式的转换对于大部分相关代码并不可见，我们只需要对执行栈帧的C函数做出修改即可。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align="left"&gt;Return Value&lt;/th&gt;
&lt;th align="left"&gt;系统状态&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td align="left"&gt;NULL&lt;/td&gt;
&lt;td align="left"&gt;函数执行异常&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Py_UnwindToken&lt;/td&gt;
&lt;td align="left"&gt;调度函数栈帧&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align="left"&gt;Other PyObject&lt;/td&gt;
&lt;td align="left"&gt;作为正常结果返回&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1&gt;参考资料&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://archive.is/TwQEJ"&gt;http://archive.is/TwQEJ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.archive.org/web/20131005114137/http://www.onlamp.com/pub/a/python/2000/10/04/stackless-intro.html"&gt;https://web.archive.org/web/20131005114137/http://www.onlamp.com/pub/a/python/2000/10/04/stackless-intro.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.onlamp.com/pub/a/python/2002/02/14/pythonnews.html"&gt;http://www.onlamp.com/pub/a/python/2002/02/14/pythonnews.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://web.archive.org/web/20120508092636/http://islab.org/stackless/2007/stackless.html"&gt;https://web.archive.org/web/20120508092636/http://islab.org/stackless/2007/stackless.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ep2013.europython.eu/conference/talks/the-story-of-stackless-python"&gt;https://ep2013.europython.eu/conference/talks/the-story-of-stackless-python&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.python.org/dev/peps/pep-0219/"&gt;https://www.python.org/dev/peps/pep-0219/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.python.org/dev/peps/pep-0342/"&gt;https://www.python.org/dev/peps/pep-0342/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content><category term="stackless"></category><category term="python"></category></entry></feed>